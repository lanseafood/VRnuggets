<!doctype html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <link href="css/main.css" rel="stylesheet" />
    
    <script src="js/three.min.js"></script>
    <script src='js/OrbitControls.js'></script>
    <!-- Include tar.js if you want to export PNG or JPEG -->
    <script src="js/tar.js"></script>
    <!-- Include download.js for easier file download -->
    <script src="js/download.js"></script>
    <!-- 360 capture section -->
    <script src="js/CubemapToEquirectangular.js"></script>
    <!-- lanssie part -->

  </head>
  <body>
    <div id="container"></div>

    <div id="controls">
      <button class="startButton" onclick="startCapture360()">Record</button>
      <button class="stopButton" onclick="stopCapture360()">Stop</button>
    </div>

    <!-- movie capture section -->
    <script src="js/CCapture.js"></script>

    <script> 
      // globals ---

      var center;
      var left;
      var right;

      var group;
      var container, controls, stats;
      var particlesData = [];
      var camera, scene, renderer;
      var positions, colors;
      var particles;
      var pointCloud;
      var particlePositions;
      var linesMesh;
      var maxParticleCount = 1000;
      var particleCount = 500;
      var r = 800;
      var rHalf = r / 2;
      var effectController = {
        showDots: true,
        showLines: true,
        minDistance: 150,
        limitConnections: false,
        maxConnections: 20,
        particleCount: 500
      };

      // Create a capturer that exports Equirectangular 360 JPG images in a TAR file
      var capturer360 = new CCapture({
        format: 'threesixty',
        display: true,
        autoSaveTime: 3,
      });

      function startCapture360(event) {
        capturer360.start();
      }

      function stopCapture360(event) {
        capturer360.stop();
        capturer360.save();
      }

      // functions
      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      animate();

      function init() {
        // create a scene, that will hold all the elements such as objects, cameras and lights.
        scene = new THREE.Scene();

        // create a camera, which defines where you're looking at.
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 4000);
        camera.position.z = 200; // needs to be >0 for orbit controls to work

        // create a renderer, sets the background color and the size
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // add a managed CubemapToEquirectangular camera
        equiManaged = new CubemapToEquirectangular(renderer, true, "4K");
        
        // set up orbit controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // start world ---
        
        group = new THREE.Group();
        scene.add(group);

        var helper = new THREE.BoxHelper( new THREE.Mesh( new THREE.BoxGeometry( r, r, r ) ) );
        helper.material.color.setHex( 0x080808 );
        helper.material.blending = THREE.AdditiveBlending;
        helper.material.transparent = true;
        group.add( helper );
        var segments = maxParticleCount * maxParticleCount;
        positions = new Float32Array( segments * 3 );
        colors = new Float32Array( segments * 3 );
        var pMaterial = new THREE.PointsMaterial( {
          color: 0xFFFFFF,
          size: 3,
          blending: THREE.AdditiveBlending,
          transparent: true,
          sizeAttenuation: false
        } );
        particles = new THREE.BufferGeometry();
        particlePositions = new Float32Array( maxParticleCount * 3 );
        for ( var i = 0; i < maxParticleCount; i++ ) {
          var x = Math.random() * r - r / 2;
          var y = Math.random() * r - r / 2;
          var z = Math.random() * r - r / 2;
          particlePositions[ i * 3     ] = x;
          particlePositions[ i * 3 + 1 ] = y;
          particlePositions[ i * 3 + 2 ] = z;
          // add it to the geometry
          particlesData.push( {
            velocity: new THREE.Vector3( -1 + Math.random() * 2, -1 + Math.random() * 2,  -1 + Math.random() * 2 ),
            numConnections: 0
          } );
        }
        particles.setDrawRange( 0, particleCount );
        particles.addAttribute( 'position', new THREE.BufferAttribute( particlePositions, 3 ).setDynamic( true ) );
        // create the particle system
        pointCloud = new THREE.Points( particles, pMaterial );
        group.add( pointCloud );
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).setDynamic( true ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).setDynamic( true ) );
        geometry.computeBoundingSphere();
        geometry.setDrawRange( 0, 0 );
        var material = new THREE.LineBasicMaterial( {
          vertexColors: THREE.VertexColors,
          blending: THREE.AdditiveBlending,
          transparent: true
        } );
        linesMesh = new THREE.LineSegments( geometry, material );
        group.add( linesMesh );

        // end world ---

        // /render
        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        // add the output of the renderer to the html element
        // document.body.appendChild(renderer.domElement);
        var container = document.getElementById('container');
        container.appendChild(renderer.domElement);

        // call the render function, after the first render, interval is determined
        // by requestAnimationFrame
        // render();
              // calls the handleResize function when the window is resized
        window.addEventListener('resize', handleResize, false);

      }


      function render() {
        // center.rotation.x += 0.01;
        // center.rotation.y += 0.02;
        var time = Date.now() * 0.001;
        group.rotation.y = time * 0.1;

        // --

        renderer.render(scene, camera);

        // requestAnimationFrame(render);

        controls.update();

        // add at the end of your render loop
        capturer360.capture(renderer.domElement);
      }

      function animate(){
        var vertexpos = 0;
        var colorpos = 0;
        var numConnected = 0;
        for ( var i = 0; i < particleCount; i++ )
          particlesData[ i ].numConnections = 0;
        for ( var i = 0; i < particleCount; i++ ) {
          // get the particle
          var particleData = particlesData[i];
          particlePositions[ i * 3     ] += particleData.velocity.x;
          particlePositions[ i * 3 + 1 ] += particleData.velocity.y;
          particlePositions[ i * 3 + 2 ] += particleData.velocity.z;
          if ( particlePositions[ i * 3 + 1 ] < -rHalf || particlePositions[ i * 3 + 1 ] > rHalf )
            particleData.velocity.y = -particleData.velocity.y;
          if ( particlePositions[ i * 3 ] < -rHalf || particlePositions[ i * 3 ] > rHalf )
            particleData.velocity.x = -particleData.velocity.x;
          if ( particlePositions[ i * 3 + 2 ] < -rHalf || particlePositions[ i * 3 + 2 ] > rHalf )
            particleData.velocity.z = -particleData.velocity.z;
          if ( effectController.limitConnections && particleData.numConnections >= effectController.maxConnections )
            continue;
          // Check collision
          for ( var j = i + 1; j < particleCount; j++ ) {
            var particleDataB = particlesData[ j ];
            if ( effectController.limitConnections && particleDataB.numConnections >= effectController.maxConnections )
              continue;
            var dx = particlePositions[ i * 3     ] - particlePositions[ j * 3     ];
            var dy = particlePositions[ i * 3 + 1 ] - particlePositions[ j * 3 + 1 ];
            var dz = particlePositions[ i * 3 + 2 ] - particlePositions[ j * 3 + 2 ];
            var dist = Math.sqrt( dx * dx + dy * dy + dz * dz );
            if ( dist < effectController.minDistance ) {
              particleData.numConnections++;
              particleDataB.numConnections++;
              var alpha = 1.0 - dist / effectController.minDistance;
              positions[ vertexpos++ ] = particlePositions[ i * 3     ];
              positions[ vertexpos++ ] = particlePositions[ i * 3 + 1 ];
              positions[ vertexpos++ ] = particlePositions[ i * 3 + 2 ];
              positions[ vertexpos++ ] = particlePositions[ j * 3     ];
              positions[ vertexpos++ ] = particlePositions[ j * 3 + 1 ];
              positions[ vertexpos++ ] = particlePositions[ j * 3 + 2 ];
              colors[ colorpos++ ] = alpha;
              colors[ colorpos++ ] = alpha;
              colors[ colorpos++ ] = alpha;
              colors[ colorpos++ ] = alpha;
              colors[ colorpos++ ] = alpha;
              colors[ colorpos++ ] = alpha;
              numConnected++;
            }
          }
        }
        linesMesh.geometry.setDrawRange( 0, numConnected * 2 );
        linesMesh.geometry.attributes.position.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;
        pointCloud.geometry.attributes.position.needsUpdate = true;
        requestAnimationFrame( animate );
        render();

      }

      // calls the init function when the window is done loading.
      window.onload = start();

      function start(){
        init;
        animate;
      }

    </script>
  </body>
</html>