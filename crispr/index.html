<!doctype html>
<html>
  <head>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      #world {
        position: absolute;
        width: 100%;
        height: 100%;
        background: linear-gradient(#e4e0ba, #f7d9aa);
      }
    </style>
    <script src="three.js"></script>
    <script>
      // globals ---
      var scene;
      var renderer;
      var camera;
      var hemisphereLight;
      var shadowLight;

      var ribosome;
      var dna;
      var rna;
      var scale = 1;
      var cas;

      var is1pressed = false;
      var is2pressed = false;
      var is3pressed = false;

      // color palette
      var colors = {
        red: 0xf25346,
        white: 0xd8d0d1,
        brown: 0x59332e,
        pink: 0xF5986E,
        brownDark: 0x23190f,
        blue: 0x68c3c0,
      };

      // objects ---
      Ribosome = function() {
        // Create an empty container that will hold the different parts of the shape
        
        this.obj = new THREE.Object3D();
        
        var geometry = new THREE.BoxGeometry(10,10,10);
        var material = new THREE.MeshPhongMaterial({
          color: colors.brown,  
        });

        // var numBlocks = Math.floor(Math.random() * 3) + 3;
        for(var i=0; i<3; i++) {
          // make a mesh
          var tempMesh = new THREE.Mesh(geometry, material);
          
          tempMesh.position.x = i*5;
          tempMesh.position.y = Math.random() * 10;
          // tempMesh.position.z = Math.random() * 10;

          tempMesh.rotation.y = Math.random() * Math.PI * 2;
          tempMesh.rotation.z = Math.random() * Math.PI * 2;

          // var size = Math.random() * 0.15;
          // tempMesh.scale.set(size, size, size);

          // allow each cube to cast and receive shadows
          tempMesh.castShadow = true;
          tempMesh.receiveShadow = true;

          // add the cube to the container
          this.obj.add(tempMesh);
        }
      }


      // objects ---
      Cas = function() {
        // Create an empty container that will hold the different parts of the shape
        
        this.obj = new THREE.Object3D();
        
        var geometry = new THREE.BoxGeometry(7,7,7);
        var material = new THREE.MeshPhongMaterial({
          color: colors.red,  
        });

        // var numBlocks = Math.floor(Math.random() * 3) + 3;
        for(var i=0; i<2; i++) {
          // make a mesh
          var tempMesh = new THREE.Mesh(geometry, material);
          
          tempMesh.position.x = i*5;
          tempMesh.position.y = Math.random() * 10;
          // tempMesh.position.z = Math.random() * 10;

          tempMesh.rotation.y = Math.random() * Math.PI * 2;
          tempMesh.rotation.z = Math.random() * Math.PI * 2;

          // var size = Math.random() * 0.15;
          // tempMesh.scale.set(size, size, size);

          // allow each cube to cast and receive shadows
          tempMesh.castShadow = true;
          tempMesh.receiveShadow = true;

          // add the cube to the container
          this.obj.add(tempMesh);
        }
      }

      // helpers ---
      
      function handleResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      var CustomSinCurve = THREE.Curve.create(
        // custom curve constructor
        function (scale) { 
          this.scale = (scale === undefined) ? 1 : scale;
        },

        // getPoint: t is between 0-1
        function (t) {
          var tx = t * 5 - 1.5;
          var ty = Math.sin( 1.5 * Math.PI * t );
          var tz = 0;
          return new THREE.Vector3( tx, ty, tz ).multiplyScalar( this.scale );
        }
      );

      function onDocumentKeyDown(event){ 
        // Get the key code of the pressed key 
        var keyCode = event.which; 
        if(keyCode == 49) {
          is1pressed = true;  
        }
        if(keyCode == 50) {
          is2pressed = true;  
        }
        if(keyCode == 51) {
          is3pressed = true;  
        }
      }

      // main ---
      function init() {
        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;

        // 1. Create the renderer
        renderer = new THREE.WebGLRenderer({ 
          // Allow transparency to show the gradient background
          // we defined in the CSS
          alpha: true, 

          // Activate the anti-aliasing; this is less performant,
          // but, as our project is low-poly based, it should be fine :)
          antialias: true 
        });

        // Define the size of the renderer; in this case,
        // it will fill the entire screen
        renderer.setSize(WIDTH, HEIGHT);

        // Enable shadow rendering
        renderer.shadowMapEnabled = true;


        // 2. Create the scene
        scene = new THREE.Scene();

        // Add a fog effect to the scene; same color as the
        // background color used in the style sheet
        scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);


        // 3. Create the camera
        aspectRatio = WIDTH / HEIGHT;
        fieldOfView = 60;
        nearPlane = 0.1;
        farPlane = 1000;
        camera = new THREE.PerspectiveCamera(
          fieldOfView,
          aspectRatio,
          nearPlane,
          farPlane
          );

        // Set the position of the camera
        camera.position.x = 45;
        camera.position.z = 46;
        camera.position.y = 43;
        camera.lookAt(scene.position);


        // 4. add lights
        // A hemisphere light is a gradient colored light; 
        // the first parameter is the sky color, the second parameter is the ground color, 
        // the third parameter is the intensity of the light
        hemisphereLight = new THREE.HemisphereLight(0xaaaaaa,0x000000, .9)

        // A directional light shines from a specific direction. 
          // It acts like the sun, that means that all the rays produced are parallel. 
          shadowLight = new THREE.DirectionalLight(0xffffff, .9);

          // Set the direction of the light  
          shadowLight.position.set(150, 350, 350);
          
          // Allow shadow casting 
          shadowLight.castShadow = true;

          // define the visible area of the projected shadow
          shadowLight.shadow.camera.left = -400;
          shadowLight.shadow.camera.right = 400;
          shadowLight.shadow.camera.top = 400;
          shadowLight.shadow.camera.bottom = -400;
          shadowLight.shadow.camera.near = 1;
          shadowLight.shadow.camera.far = 1000;

          // define the resolution of the shadow; the higher the better, 
          // but also the more expensive and less performant
          shadowLight.shadow.mapSize.width = 2048;
          shadowLight.shadow.mapSize.height = 2048;
          
          // to activate the lights, just add them to the scene
          scene.add(hemisphereLight);  
          scene.add(shadowLight);


        // 5. add objects
        ribosome = new Ribosome();
        ribosome.name = 'ribosome';
        ribosome.obj.position.x = 30;
        ribosome.obj.position.y = 8;
        scene.add(ribosome.obj);

        var dnaGeometry = new THREE.BoxGeometry(60, 1, 1);
        var dnaMaterial = new THREE.MeshPhongMaterial({
          color: colors.blue,  
        });
        dna = new THREE.Mesh(dnaGeometry, dnaMaterial);
        dna.name = 'dna';
        dna.position.y = 10;
        scene.add(dna);

        var path = new CustomSinCurve(1);
        var rnaGeometry = new THREE.TubeGeometry(path, 64, 0.5, 8, false);
        var rnaMaterial = new THREE.MeshNormalMaterial( { color: 0x3D98D4 } );
        var rna = new THREE.Mesh(rnaGeometry, rnaMaterial);
        rna.name = 'rna'
        rna.position.x = 30;
        rna.position.y = 5;
        scene.add(rna);

        cas = new Cas();
        cas.name = 'cas';
        cas.obj.position = -15;
        cas.obj.position.y = -30;
        scene.add(cas.obj);

        container = document.getElementById('world');
        container.appendChild(renderer.domElement);

        document.addEventListener("keydown", onDocumentKeyDown, false); 

        render();
      }

      function render() {
        // requestAnimationFrame tells the browser to deterine when its best to call render, which visualizes the scene
        requestAnimationFrame(render);
        
        // visualize the scene using the camera
        renderer.render(scene, camera);

        // 1. ribosome moves across dna
        var rna = scene.getObjectByName('rna')
        if(is1pressed) {
          if(ribosome.obj.position.x > -25) {
            ribosome.obj.position.x -= 0.2;

            rna.position.x -= 0.2;
            scale += 0.05
            rna.scale.set(scale, 1, 1);
          }
        }

        // 2. ribosome falls away
        if(is2pressed) {
          if(ribosome.obj.position.x > -700) {
            ribosome.obj.position.x -= 3;
            ribosome.obj.position.y -= 3;
            dna.position.y -= 1;
          }
        }

        // 3. cas attaches to rna
        if(is3pressed) {
            if(cas.obj.position.x <= 9) {
            cas.obj.position.x += 0.2;
          }
          if(cas.obj.position.y <= -3.5) {
            cas.obj.position.y += 0.2;
          }
        }
      }

      // run ---

      window.onload = init;
      window.addEventListener('resize', handleResize, false);
    </script>
  </head>
  <body>
    <div id="world"></div>
  </body>
</html>